### 参考

笔记：https://github.com/7kms/assembly?tab=readme-ov-file

环境配置：https://blog.csdn.net/qq_19782019/article/details/88913885

汇编程序的本质

1. 分为多个段，如代码段、数据段、栈段
2. 寻址把数据从内存搬到寄存器，CPU读取寄存器进行运算，将寄存器中的结果写入到内存
3. 寄存器相当于一个变量

CPU从哪取数据？

1. 立即数，在CPU的指令缓冲器中
2. 寄存器
3. 内存

CPU组成

- 运算器：信息处理
- 控制器：控制
- 寄存器：信息存储

cpu与内存进行交互

- 地址总线：地址总线的宽度决定了CPU的寻址能力
- 数据总线：数据总线的宽度决定了CPU与其他器件的单次数据传送量
- 控制总线：控制总线的宽度决定了CPU对其他器件的控制能力

寄存器

通用寄存器

- 16位：AX、BX、CX、DX
- 8位：AH/AL、BH/BL、CH/CL、DH/DL
- CX：存放程序的长度

偏移寄存器
BX/SI/DI

指令

- 入栈/出栈：pop/push
- 传送：mov
- 跳转：jmp
- 加减：add/

段寄存器

- CS：指令段
- DS：数据段
- SS：栈段
- ES

常用组合

- 任意时刻，CS:IP指向下一条执行的指令
- 任意时刻，SS:SP指向栈顶元素地址
- jmp修改CS:IP
- 8086CPU不支持直接将数据送入段寄存器
- 8086CPU栈顶从高地址向低地址增长

寻址

8086CPU有20位地址总线，但内部寄存器只有16位

通过两个16位地址转换为一个20位地址，即段地址+偏移地址

物理地址=段地址*16+偏移地址



指令

伪指令

1. <段名> segment <段名> ends：用于标识一个段的开始和结束
2. end：标记整个程序的结束
3. assume：用于将当前的段和CPU的段寄存器关联起来

程序返回



```assembly
mov ax,4c00H
int 21H
```

编译链接

假设源文件为：1.asm

1. 打开DOSBox
2. 编译：masm 1;
3. 链接：link 1;

调试程序

- 调试：debug 1.exe
- 退出调试：q
- 查看寄存器：r
- 查看其他指令：u
- 执行一条指令：t
- int21用p指令执行

进度

96页



